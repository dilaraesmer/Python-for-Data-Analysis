# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-whTW9Sc3N-yxyq-mYNVrC_ZOdC7uL6a

VARIABLES

After assigning a variable, you can access its associated value or object using the variable's name. Variables are a convenient way of storing values with names that are meaningful. 

In Python, assign variables using "=":
"""

x = 10
y = "Python is fun"
z = 144**0.5 == 12

print(x)
print(y)
print(z)

"""Note: When assigning a variable does not produce any output. 
Put a space between the variable name, the assignment operator and the variable value for clarity:
"""

p=8 #This works, but it looks messy
print(p)
p = 12 # Use spaces instead 
print(p)

"""As shown above, you can reassign a variable after creating it by assigning the variable name a new value. After assigning variables, you can perform operations on the objects assigned to them using their names: 

"""

x + z + p

"""You can assign the same object to multiple variables with a multiple assignmet statement.

"""

n = m = 6
print(n)
print(m)

"""You can also assign several different variables at the same time using a comma separated sequence of variable names followed by the assignment operator and a comma separated sequence of values inside parantheses:"""

# Assign three variables at the same time:
x, y, z = (5, 13, 8)
print(x)
print(y)
print(z)

"""This method of extracting variables from a comma separated sequence is known as "tuple unpacking." 
You can swap the values of the two variables using a similar syntax:

"""

(x, y) = (y, x)

print(x)
print(y)

"""When you assign a variable in Python, the variable is a reference to a specific object in the computer's memory. Reasigning a variable simply switches the reference to a different object in memory. If the object a variable refers to in memory is altered in some way., the value of the variable corresponding to the altered object will also change. If the perform some operation that appears to alter an immutable object, it is actually creating a totally new object in memory, rather than changing the original immutable object. """

x = "Hello" # Create a new string
y = x # Assign y the same object as x
y = y.lower() # Assign y the result of y.lower()
print(x)
print(y)

"""In the case above, we first assign x the value "Hello", a string objected stored somewhere in memory. Next we use the string method lower() to make the string assigned to y lowercase. Since strings are immutable, Python creates an entirely new string, "hello" and stores it somewhere in memory separate from the original "Hello" object. As a result, x and y refer to different objects in memory and produce different results when printed to the console. 

By contrast, lists are mutable data structure that can hold multiple objects. If you alter a list, Python doesn't make an entirely new list in memory: it changes the actual list object itself. This can lead to seemingly inconsistent and confusing behavior:
"""

x =[5,6,7] # Create a new list
y = x # Assign y the same object as x
y.append(8) # Add eight to the end of list y
print(x)
print(y)

"""In this case, x and y still both refer to the original list, so both x and y have the same value, even though it may appear that the code only added the number 8 to list y."""